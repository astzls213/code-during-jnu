### **@本程序提供两种方式获取各字符的频率。**

##### 1.扫描文本各个可见字符的频率，从而构建huffman树。

原理：通过打开特指的文件，不断循环地扫描各字符，并在对应的ascii码值的数组下标元素值加1。即：

%1声明一个int数组frequencyTable，大小为95.（可见字符数）

%2fgets（）得到文件名，fopen（）打开对应文件，模式只读。

%3令int tmp=getc（），再frequencyTable[tmp-32]++。

##### 2.人工手动输入各个字符频率权值，但这样只适用于字符种类较少时。

### **@通过构建最小堆，为构建哈夫曼树做准备。**

原理：

​	先定义堆的数据结构：容量capacity，当前大小size，元素类型数组data。

若通过手动输入频率的方法，会提示输入字符的个数n，那么可以直接就malloc一块n*sizeof（元素类型）大小的空间给堆->数组。然后依次将权值和字符写入数组中。（注意，此时并不满足堆序性）

注意，初始化最小堆时，往往将data[0]=MIN（哨兵元素），这样有利于insert操作（下文会提到）。故应从下标为1开始写入数据

通过MinHeapStatus()函数，将刚刚写入的数据调整成最小堆。原理是从最后一个有儿子的节点开始，依次判断该节点元素是否比儿子更大，若更大，将两个儿子之间最小元素“交换”（并不是真正交换元素值，这里用到一种叫做“下滤”的概念，即只将儿子中较小元素的值写给该节点，这位儿子的值并没有改变成其父节点的值。而是当该父节点的值的确比该儿子的子堆更小，才写入。）

### **@不断pop出最小堆的根节点，形成哈夫曼树**

原理：

得益于最小堆的特征，我们可以利用该结构的既定事实——根即为在数组中最小的元素。

连续调用delMin（）两次（每次都能保证堆序性），即可得到一个哈夫曼子树，该子树的节点为根的两个子树的权值之和。那么，又将该子树的根节点插入到最小堆中（保持堆序性）。如此往复不断。即可得到最优二叉树。

DelMin（）保持堆序性的方法在于：删除时，我们先删除data的最后一个元素，先保存该元素值tmp，再令size--，并不是真的抹去数组中值（懒惰删除）。现在，保存堆的根节点的值rtv（return rtv），并将根节点的值改写为tmp。通过上文解释的“下滤”概念，即可保证堆序性。

Insert（）保持堆序性的方法在于：我们只需令data[++size]=value，再通过“上滤”（“下滤”的反向操作：用该节点与其父节点作比较，若不满足堆序性，则将该节点的值改写为父节点的值，然后又与父节点的父节点作比较……直至满足堆序性为止。）即可满足堆序性。

### **@哈夫曼树的可视化**

原理：

​	有两种可视化的方法：

​	1.完全表示法，如：(适用于树高小于5)

```
       *
      / \
     /   \
    /     \
   /       \
  *         d
 / \
A   b
```

​	2.压缩表示法，如：  （适用于树高小于8，若大于8则无法在console可视化）                                                       

```
               *                                                 
          /         \                                                                  
         *           c
       /   \
      *     d                                                                         
     / \                                                                          
    e   f
```

这两种可视化方法的算法十分简单，只需找出每个高度第一个节点的位置坐标，以及每个树高对应的‘/’的个数。文件保存在名叫huffmanTreeVisualization的文件中。（cmake-build-debug目录下）

其中法一与法二的row公式分别为3*2^(N-1)、2N+1

Col公式为3*2^N-1

限于篇幅有限，详情原理在huffmanOp.c的printHuffmanTree（）有代码注释。

### **@编码**

原理：

​	用递归的方式，获取对应字符的相应哈夫曼码。类似于先序遍历，首先getCode（Node huff,FILE *file,int path[]）接受三个参数，path参数是保留已走过的路径（0代表左，1代表右）。只要该节点的左儿子的左儿子不为NULL，就说明该节点是一个合成节点。这时使path[i++]=0(注意，i为static int类型，因为该函数需要递归，必须使用static保证每一个函数的i的值一致)，递归调用getCode。若为NULL，说明是字符节点，那么就打印该节点的左儿子节点路径（先打印path，再打印个0）。然后类似，判断该节点的右儿子的右儿子是否为NULL……以下为代码直观解释。

if(huff->left->left!=NULL)

​    {

​        *(path+i++)=0;

​        getCode(huff->left,file,path);

​        i--;

​    }

**由于现在是将编码写在文件Huffman中，我们要将其读入内存里**，我使用了哈希表来储存这些编码。散列函数也很简单，就是字符对应的ascii码。哈希数组的类型是字符串类型，把对应的编码变成字符串储存在数组中，方便编码（即编码时间复杂度为O(n)，n为文件字符个数）

现得到各字符编码，通过扫描目标文件的各个字符，即可将对应字符的编码写到文件CodeFile中。

### **@译码**

原理：

​	对CodeFile中的字符（“1”，“0”）进行依次扫描，每次将其放在一个tmp的字符数组中，并且每次添加在’\0’的位置上，再在该位置的下一个位置改写为’\0’。数组大小为：树高+1。（+1是为了储存\0）。每次添加后，对哈希表中的所有元素进行比较（利用strcmp（char*,char*）函数）。如果有相同的，就将该哈希表下标i+32的字符（散列函数）写入文件TextFile中。若都没找到，那就进行下一个字符扫描，并添加。以此类推。这样的最坏时间复杂度为O（N*95），其中N为CodeFile的字数。