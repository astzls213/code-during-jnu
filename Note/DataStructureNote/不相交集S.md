# 不相交集S

### 刚入门的想法：

​	初次接触这个ADT时，我的想法是把union这个操作，变成将另外一个集合S2中的所有元素都接至S1中，这样find的时间复杂度就变成O（1）了！我还好奇为什么这样不是最优解呢。但后来，我忽略了union的时间复杂度已达到O（N）。如果平均来看，就是说find和union的操作次数一样多的时候，时间复杂度为O（NM+M)。而按秩求并+路径压缩的最坏情形才是O（Mœ（M，N））。N是指规模，M是指操作次数。假设$M≥N$.

​	这里的œ（N，N）是$œ(M,N)=min{i≥1|A(i,[M/N])>logN}$.

​	而$A(i,j)$是指Ackermann函数。可自行百度或goto: mathworld.wolfram.com查询

#### 1.按秩求并（对union的优化）

​	1⃣️按高度求并：

​		利用根节点的值为负数的特点，不妨令S[Root]=-树高。再在合并时判断两根的树高，树矮的一方接入树高的一方。最坏情况是：每次合并的树高都是一样的，导致每次合并后生成的树都比原来两棵树高1。不断这样N次，树高为N，集合元素总数为2^N。导致find例程的时间复杂度为O（logM）。

​	2⃣️按大小求并：

​		和按高度求并一样，只是S[Root]=-规模。规模是指集合中元素的总数。同样地，规模小的接入规模大的。不同的地方是，按高度求并后树的高度不一定变化，而按大小求并后新树的规模则一定是两树规模之和。同样地，不断以最坏情况接入，树的规模设为M，那么find例程的时间复杂度为O（logM）。

#### 2.路径压缩（对find对优化）

​	所谓路径压缩，就是指每次find后，从要找的元素到最终根节点这条路径上，我们将该路径上所有的节点都接入到最终的总节点上。这样的话，考虑对**最坏情况**的**按秩求并的集合**的**最尾一个元素**进行find，那么时间复杂度将会是O（2*logM）。但如果以后再查这个元素或者这条路径上的元素时，我们只需O（1）的时间。

